import asyncio
from apify import Actor
from langgraph.graph import StateGraph, END
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from src.models import FinancialAnalystState
from src.tools import get_financials, get_stock_sentiment, perform_technical_analysis
from src.ppe_utils import charge_for_actor_start, charge_for_model_tokens
import os

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_API_BASE = os.getenv("OPENAI_API_BASE", "https://api.openai.com/v1")

def fetch_data(state: FinancialAnalystState):
    """Fetch stock data (Fundamentals & Sentiment)."""
    Actor.log.info(f"Fetching financial data for {state.ticker}...")
    state.financial_data = get_financials.invoke({"ticker": state.ticker})  
    state.sentiment_data = get_stock_sentiment.invoke({"ticker": state.ticker}) 
    Actor.log.info("Financial and sentiment data fetched.")
    return state

def fetch_technical(state: FinancialAnalystState):
    """Perform technical analysis."""
    Actor.log.info(f"Performing technical analysis for {state.ticker}...")
    state.technical_data = perform_technical_analysis.invoke({"ticker": state.ticker}) 
    Actor.log.info("Technical analysis completed.")
    return state

def generate_insights(state: FinancialAnalystState):
    """Generate AI analysis based on stock data, technical indicators, fundamentals, and sentiment."""
    Actor.log.info("Generating AI-based stock insights...")

    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a financial analyst providing stock market insights."),
        ("user", """Analyze the stock {ticker} based on...

        1. **Recent closing prices and trends**.
        2. **Technical indicators** (SMA, EMA, RSI, MACD, Bollinger Bands).
        3. **Financial Ratios** (P/E Ratio, P/B Ratio, EBITDA, Debt-to-Equity, ROE).
        4. **Financial Statements** (Income Statement, Balance Sheet, Cash Flow).
        5. **Market sentiment** from recent news.

        Provide a detailed summary on stock momentum, key risks, financial stability, and any bullish or bearish signals in markdown format.
        """)
    ])

    llm = ChatOpenAI(model="gpt-3.5-turbo",openai_api_key=OPENAI_API_KEY,openai_api_base=OPENAI_API_BASE)
    chain = prompt | llm
    response = chain.invoke({"ticker": state.ticker})
    Actor.log.info(f'Received response from OpenAI: {response}')
    total_tokens = response.response_metadata["token_usage"]["total_tokens"]
    asyncio.create_task(charge_for_model_tokens("gpt-3.5-turbo", total_tokens))

    state.analysis = response.content
    
    # Generate & Save Report
    asyncio.create_task(save_report(state))
    
    return state

async def save_report(state: FinancialAnalystState):
    """Save the stock analysis report in markdown format & store in Apify KV Store."""

    try:
        # Ensure `state.analysis` is safely retrieved
        ai_insights = state.analysis if state.analysis else "_No AI insights generated._"

        report_content = f"""# üìä AI Financial Analyst Report

## üìå **Stock Analysis Report**
- **Ticker Symbol:** `{state.ticker}`
- **Generated by:** Apify AI Financial Analyst

---

## üîç **AI-Generated Insights**
{ai_insights}

---

## üìä **Fundamental Analysis**
| Metric               | Value |
|----------------------|-------|
| **Revenue**         | ${state.financial_data.get("income_statement", {}).get("Revenue", "N/A")} |
| **Net Income**      | ${state.financial_data.get("income_statement", {}).get("Net Income", "N/A")} |
| **EBITDA**          | ${state.financial_data.get("income_statement", {}).get("EBITDA", "N/A")} |
| **EPS**             | ${state.financial_data.get("income_statement", {}).get("EPS", "N/A")} |
| **P/E Ratio**       | {state.financial_data.get("ratios", {}).get("P/E Ratio", "N/A")} |
| **P/B Ratio**       | {state.financial_data.get("ratios", {}).get("P/B Ratio", "N/A")} |
| **Debt-to-Equity**  | {state.financial_data.get("ratios", {}).get("Debt-to-Equity", "N/A")} |
| **Return on Equity (ROE)** | {state.financial_data.get("ratios", {}).get("Return on Equity (ROE)", "N/A")}% |

---

## üìà **Technical Analysis**
| Indicator      | Value |
|---------------|-------|
| **SMA (50)**  | {state.technical_data.get("SMA_50", "N/A")} |
| **SMA (200)** | {state.technical_data.get("SMA_200", "N/A")} |
| **EMA (50)**  | {state.technical_data.get("EMA_50", "N/A")} |
| **EMA (200)** | {state.technical_data.get("EMA_200", "N/A")} |
| **RSI**       | {state.technical_data.get("RSI", "N/A")} |
| **MACD**      | {state.technical_data.get("MACD", "N/A")} |
| **MACD Signal** | {state.technical_data.get("MACD_Signal", "N/A")} |
| **Bollinger Upper** | {state.technical_data.get("Bollinger_Upper", "N/A")} |
| **Bollinger Lower** | {state.technical_data.get("Bollinger_Lower", "N/A")} |
| **Supertrend** | {state.technical_data.get("Supertrend", "N/A")} |
| **Long Entry?** | {"‚úÖ Yes" if state.technical_data.get("longentry") else "‚ùå No"} |
| **Short Entry?** | {"‚úÖ Yes" if state.technical_data.get("shortentry") else "‚ùå No"} |

---

## üì∞ **Sentiment Analysis**
- **Highest Sentiment:** `{state.sentiment_data.get("highest_sentiment", "N/A")}`

"""

        # **Iterate Over News Headlines (if available)**
        if state.sentiment_data.get("news_data"):
            report_content += "\n### üì∞ Recent News Headlines:\n"
            
            for i, news in enumerate(state.sentiment_data.get("news_data", []), 1):
                title = news.get('title', 'No title available')
                link = news.get('url', '#')  # Default to '#' if no URL exists
                report_content += f"- [{title}]({link})\n"
        else:
            report_content += "\n### üì∞ Recent News Headlines: No news available\n"

        report_content += """

---

*üìå This report was automatically generated by the AI Financial Analyst system. For investment decisions, please conduct further research and consult financial experts.*
"""

        # **Try saving the report locally**
        report_path = f"report_{state.ticker}.md"
        try:
            with open(report_path, "w", encoding="utf-8") as file:
                file.write(report_content)
            Actor.log.info(f"Report successfully saved locally: {report_path}")
        except Exception as e:
            Actor.log.error(f"Failed to save report locally: {e}")

        # **Try storing the report in Apify Key-Value Store**
        try:
            store = await Actor.open_key_value_store()
            await store.set_value('report.md', report_content)
            Actor.log.info('Saved the "report.md" file into the key-value store!')
        except Exception as e:
            Actor.log.error(f"Failed to save report in Apify Key-Value Store: {e}")

    except Exception as e:
        Actor.log.error(f"Unexpected error while generating report: {e}")


# Define LangGraph workflow inside main.py
graph = StateGraph(FinancialAnalystState)
graph.add_node("fetch_data", fetch_data)
graph.add_node("fetch_technical", fetch_technical)
graph.add_node("generate_insights", generate_insights)

graph.add_edge("fetch_data", "fetch_technical")
graph.add_edge("fetch_technical", "generate_insights")
graph.set_entry_point("fetch_data")
graph.add_edge("generate_insights", END)

financial_analyst_workflow = graph.compile()


async def main():
    """Apify Actor Execution with LangGraph Workflow."""
    async with Actor:
        actor_input = await Actor.get_input() or {}
        # Charge for actor start
        await charge_for_actor_start()

        # Validate input using Pydantic
        try:
            state = FinancialAnalystState(**actor_input)
        except ValueError as e:
            Actor.log.warning(f"Invalid input: {e}")
            await Actor.push_data({"error": str(e)})
            return

        # Execute the workflow
        final_state = financial_analyst_workflow.invoke(state)

        # Push results to Apify dataset
        await Actor.push_data({
            "ticker": state.ticker,
            "financial_data": final_state.get("financial_data", {}),
            "technical_data": final_state.get("technical_data", {}),
            "sentiment_data": final_state.get("sentiment_data", {}),
            "ai_insights": final_state.get("analysis", ""),
        })

       

        Actor.log.info("Analysis completed and charged successfully!")
